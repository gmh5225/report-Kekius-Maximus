# Generated by [Mush Audit](https://mush-audit.vercel.app/)

## 关于

KEKIUS 是一个实现了 ERC20 标准的智能合约代币，名称为 "Kekius Maximus"，符号为 "KEKIUS"。该合约的主要功能包括：

- 基本的 ERC20 代币功能（转账、授权等）
- 集成了 Uniswap V2 的交易功能
- 实现了买卖交易的税收机制，税率可以动态调整
- 设有防巨鲸机制，限制单笔交易最大金额和单地址持有的最大代币数量
- 实现了防机器人（Bots）机制，可以添加或删除黑名单地址
- 合约所有者可以开启交易、移除交易限制、调整税率和管理黑名单

## 调查结果严重性分类

- **严重 (Critical)**: 可能导致资金损失或合约完全受损的问题
- **高 (High)**: 可能导致合约功能故障或中等风险的问题
- **中 (Medium)**: 可能导致意外行为的问题
- **低 (Low)**: 最佳实践违规和代码改进建议
- **Gas 优化**: 降低 Gas 成本的优化建议

## 调查结果

---

### 1. ReduceFee 函数的访问控制存在风险

- **标题**: ReduceFee 函数的访问控制存在风险
- **严重性**: 高 (High)
- **描述**:

  `ReduceFee` 函数用于调整买卖交易的最终税率 `_finalBuyTax` 和 `_finalSellTax`。目前，该函数的访问控制仅限制了调用者必须是 `_taxWallet`，即税收钱包地址。然而，`_taxWallet` 地址在合约的构造函数中被硬编码设置为了一个特定的地址。如果该地址的私钥泄露或者被恶意者控制，攻击者可以调用 `ReduceFee` 函数，将税率调整为 0，进而绕过税收机制。

- **影响**:

  攻击者可以通过控制 `_taxWallet` 地址，调用 `ReduceFee` 函数，将买卖税率调整为 0，导致合约的税收模型失效，影响代币的经济模型和收益分配。

- **位置**:

  `KEKIUS.sol`，第 284-289 行

- **建议**:

  建议将 `ReduceFee` 函数的权限控制修改为仅合约所有者（`onlyOwner`）可以调用。这样可以确保只有合约所有者才能修改税率，避免因 `_taxWallet` 地址被控制而导致的风险。此外，还可以考虑在调整税率时，添加事件日志，以便跟踪税率的变化。

  修改后的代码示例：

  ```solidity
  function ReduceFee(uint256 _newFee) external onlyOwner {
    require(_newFee <= _finalBuyTax && _newFee <= _finalSellTax, "Invalid fee");
    _finalBuyTax = _newFee;
    _finalSellTax = _newFee;
    emit FeeReduced(_newFee);
  }
  ```

---

### 2. manualSwap 函数的访问控制存在风险

- **标题**: manualSwap 函数的访问控制存在风险
- **严重性**: 高 (High)
- **描述**:

  `manualSwap` 函数用于手动触发合约中代币的兑换和税收资金的转移。目前，该函数的访问控制也仅限制了调用者必须是 `_taxWallet`。如果 `_taxWallet` 地址被恶意者控制，攻击者可以调用 `manualSwap` 函数，将合约中积累的代币兑换为 ETH，并将 ETH 转移到 `_taxWallet`，进而窃取资金。

- **影响**:

  攻击者可以通过控制 `_taxWallet` 地址，调用 `manualSwap` 函数，窃取合约中积累的税收资金，导致合约资金损失。

- **位置**:

  `KEKIUS.sol`，第 296-305 行

- **建议**:

  建议将 `manualSwap` 函数的权限控制修改为仅合约所有者（`onlyOwner`）可以调用。这样可以确保只有合约所有者才能手动触发兑换和转移资金，避免因 `_taxWallet` 地址被控制而导致的资金风险。

  修改后的代码示例：

  ```solidity
  function manualSwap() external onlyOwner {
    uint256 tokenBalance = balanceOf(address(this));
    if (tokenBalance > 0) {
      swapTokensForEth(tokenBalance);
    }
    uint256 ethBalance = address(this).balance;
    if (ethBalance > 0) {
      sendETHToFee(ethBalance);
    }
    emit ManualSwapExecuted(tokenBalance, ethBalance);
  }
  ```

---

### 3. _transfer 函数中税收计算逻辑存在问题

- **标题**: _transfer 函数中税收计算逻辑存在问题
- **严重性**: 中 (Medium)
- **描述**:

  在 `_transfer` 函数中，税收金额 `taxAmount` 的计算逻辑存在问题。

  - 当 `_buyCount == 0` 时，执行了如下计算：

    ```solidity
    taxAmount = amount.mul((_buyCount > _reduceBuyTaxAt) ? _finalBuyTax : _initialBuyTax).div(100);
    ```

  - 当 `_buyCount > 0` 时，执行了如下计算：

    ```solidity
    taxAmount = amount.mul(_transferTax).div(100);
    ```

  然而，`_transferTax` 初始值为 0，且只有在调用 `removeTransferTax` 函数时才可能被修改为 0。因此，这里的逻辑可能导致税收计算错误。此外，在买入交易时，`_buyCount` 会递增，但是在卖出交易时并不会递增，可能导致税率没有按照预期下降。

- **影响**:

  税收计算逻辑错误可能导致合约无法按照预期收取税费，影响代币的经济模型和收益分配。

- **位置**:

  `KEKIUS.sol`，第 203-210 行

- **建议**:

  建议重新梳理税收计算的逻辑，确保在买入和卖出交易中，税率的变化和计数器的递增符合预期。同时，可以在税率计算时添加清晰的注释，方便维护和理解。

  修改后的代码示例：

  ```solidity
  if (from == uniswapV2Pair && to != address(uniswapV2Router) && !_isExcludedFromFee[to]) {
    // 买入交易
    require(amount <= _maxTxAmount, "Exceeds the _maxTxAmount.");
    require(balanceOf(to).add(amount) <= _maxWalletSize, "Exceeds the maxWalletSize.");
    taxAmount = amount.mul((_buyCount >= _reduceBuyTaxAt) ? _finalBuyTax : _initialBuyTax).div(100);
    _buyCount++;
  } else if (to == uniswapV2Pair && from != address(this)) {
    // 卖出交易
    taxAmount = amount.mul((_buyCount >= _reduceSellTaxAt) ? _finalSellTax : _initialSellTax).div(100);
  } else {
    // 普通转账
    taxAmount = amount.mul(_transferTax).div(100);
  }
  ```

---

### 4. sellCount 逻辑存在问题

- **标题**: sellCount 逻辑存在问题
- **严重性**: 中 (Medium)
- **描述**:

  在 `_transfer` 函数中，`sellCount` 用于限制每个区块的卖出次数。然而，`sellCount` 的递增和重置逻辑存在问题。

  - 当满足一定条件时，`sellCount` 会递增：

    ```solidity
    if (!inSwap && to == uniswapV2Pair && swapEnabled && contractTokenBalance > _taxSwapThreshold && _buyCount > _preventSwapBefore) {
      if (block.number > lastSellBlock) {
        sellCount = 0;
      }
      require(sellCount < 3, "Only 3 sells per block!");
      // ...
      sellCount++;
      lastSellBlock = block.number;
    }
    ```

  - 然而，这部分逻辑只在自动兑换代币的情况下才会执行，普通的卖出交易并不会触发 `sellCount` 的递增。此外，`sellCount` 的重置逻辑也存在问题。

- **影响**:

  `sellCount` 无法正确限制每个区块的卖出次数，可能导致防止市场操纵和机器人交易的机制失效。

- **位置**:

  `KEKIUS.sol`，第 228-231 行

- **建议**:

  建议在卖出交易发生时，正确地递增 `sellCount`，并在区块号发生变化时重置 `sellCount`。同时，优化逻辑，确保在所有卖出情况下都能正确地限制卖出次数。

  修改后的代码示例：

  ```solidity
  if (to == uniswapV2Pair && from != address(this)) {
    // 卖出交易
    taxAmount = amount.mul((_buyCount >= _reduceSellTaxAt) ? _finalSellTax : _initialSellTax).div(100);
    // 限制每个区块的卖出次数
    if (block.number > lastSellBlock) {
      sellCount = 0;
      lastSellBlock = block.number;
    }
    require(sellCount < 3, "Only 3 sells per block!");
    sellCount++;
  }
  ```

---

### 5. 存在前置交易（Front-Running）和三明治攻击的风险

- **标题**: 存在前置交易和三明治攻击的风险
- **严重性**: 中 (Medium)
- **描述**:

  合约在执行代币兑换时，未对最小输出金额进行限制，缺乏滑点保护机制。在调用 `swapExactTokensForETHSupportingFeeOnTransferTokens` 函数时，`amountOutMin` 参数被设置为 0。这可能导致交易在价格滑点较大的情况下，产生不利的成交价格。

- **影响**:

  攻击者可以利用前置交易或三明治攻击，操纵价格，导致用户在交易中遭受损失。

- **位置**:

  `KEKIUS.sol`，第 250 行

- **建议**:

  建议在兑换代币时，设置合理的 `amountOutMin` 参数，添加滑点保护机制，防止交易在不利的价格下执行。

  修改后的代码示例：

  ```solidity
  function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
    address[] memory path = new address[](2);
    path[0] = address(this);
    path[1] = uniswapV2Router.WETH();
    _approve(address(this), address(uniswapV2Router), tokenAmount);
    uint256[] memory amounts = uniswapV2Router.getAmountsOut(tokenAmount, path);
    uint256 amountOutMin = amounts[1].mul(95).div(100); // 设置 5% 的滑点保护
    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
      tokenAmount,
      amountOutMin,
      path,
      address(this),
      block.timestamp
    );
  }
  ```

---

### 6. 重入攻击的潜在风险

- **标题**: 存在重入攻击的潜在风险
- **严重性**: 中 (Medium)
- **描述**:

  在 `swapTokensForEth` 函数中，虽然使用了 `lockTheSwap` 修饰器，然而在外部调用之前，未按照最佳实践更新状态变量，可能存在重入攻击的风险。在调用 `uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens` 之前，如果状态未正确更新，可能被恶意合约利用。

- **影响**:

  攻击者可能通过重入攻击，重复执行某些逻辑，导致合约状态异常，甚至窃取资金。

- **位置**:

  `KEKIUS.sol`，第 248-258 行

- **建议**:

  建议遵循检查-效应-交互（Checks-Effects-Interactions）模式，在进行外部调用前，先更新合约的状态变量，确保在外部调用过程中，即使发生重入，也不会影响合约的安全性。

---

### 7. Gas 优化建议

- **标题**: _transfer 函数的 Gas 优化
- **严重性**: Gas 优化
- **描述**:

  在 `_transfer` 函数中，多次使用了相同的条件判断，例如 `from != owner() && to != owner()`，以及在多处对 `amount` 进行计算，可能增加了 Gas 消耗。

- **影响**:

  合约在执行过程中，会消耗更多的 Gas，增加了用户的交易成本。

- **位置**:

  `KEKIUS.sol`，第 193-240 行

- **建议**:

  - 将重复使用的条件判断结果，存储在局部变量中，减少重复计算。
  - 合并条件判断，优化逻辑结构，减少不必要的计算。
  - 在可能的情况下，使用 `unchecked` 块，避免溢出检查。

  修改后的代码示例：

  ```solidity
  bool isOwnerTransfer = from == owner() || to == owner();
  if (!isOwnerTransfer) {
    require(!bots[from] && !bots[to], "Bots are not allowed");
    // ... 其他逻辑
  }
  ```

## 详细分析

### 架构

- 合约采用了标准的 ERC20 代币合约结构，继承了 `Ownable` 合约进行权限控制。
- 使用了 `SafeMath` 库防止整数溢出，但由于 Solidity 0.8.x 版本已经内置了溢出检查，使用 `SafeMath` 可以考虑简化。
- 集成了 Uniswap V2 的交易功能，实现了自动兑换和添加流动性。
- 实现了买卖税收机制，且税率可动态调整。
- 设有防巨鲸和防机器人机制，限制了单笔交易和单地址持有的代币数量。
- 提供了移除交易限制和移除转账税的功能。

### 代码质量

- 代码风格较为一致，采用了适当的注释，但部分注释与代码逻辑不符，需要更新。
- 没有提供事件日志来记录重要操作，例如调整税率、手动兑换等，建议添加相应的事件。
- 部分函数的访问控制不当，需要修改权限修饰符。
- 代码中存在冗余，例如 `SafeMath` 库的使用，可以考虑移除或简化。

### 中心化风险

- 合约所有者（`owner`）具有较大的权限，可以开启交易、移除限制、调整税率、管理黑名单等。
- `_taxWallet` 地址的控制权非常重要，如果被攻击者控制，可能导致资金被窃取。
- 建议将关键操作的控制权交由多签钱包，或者引入治理机制，降低中心化风险。

### 系统性风险

- 合约依赖于 Uniswap V2 协议，如果 Uniswap V2 存在漏洞，可能影响合约的安全性。
- 合约中缺乏紧急停止（Circuit Breaker）机制，在出现异常情况时，无法及时暂停合约的关键功能。

### 测试与验证

- 代码中未提供任何测试用例，无法验证合约在各种边界情况下的行为。
- 建议编写全面的单元测试和集成测试，覆盖所有核心功能和可能的异常情况。

## 最终建议

1. **修复访问控制问题**：修改 `ReduceFee` 和 `manualSwap` 函数的权限控制，使用 `onlyOwner` 修饰符，确保只有合约所有者可以调用。

2. **优化税收逻辑**：重新梳理税收计算逻辑，确保买卖交易的税率变化和计数器的递增符合预期。

3. **修复卖出次数限制的逻辑**：调整 `sellCount` 的递增和重置逻辑，确保每个区块的卖出次数限制生效。

4. **添加滑点保护**：在代币兑换过程中，设置 `amountOutMin`，防止交易在不利的价格下执行，抵御前置交易和三明治攻击。

5. **遵循最佳实践**：在外部调用之前，先更新合约的状态变量，防止重入攻击。

6. **优化代码**：减少重复计算，合并条件判断，优化代码结构，降低 Gas 消耗。

7. **加强安全审计**：定期对合约进行安全审计，及时发现和修复潜在的安全漏洞。

8. **完善测试用例**：编写全面的测试用例，覆盖所有功能和异常情况，确保合约的可靠性。

9. **添加事件日志**：在关键操作中添加事件日志，方便跟踪和审计合约的运行情况。

10. **降低中心化风险**：考虑将关键操作的控制权交由多签钱包，或者引入治理机制，分散合约的控制权限。

## 改进的代码，包含安全注释

```solidity
// SPDX-License-Identifier: UNLICENSE

pragma solidity 0.8.23;

// ...（省略合同头部注释）...

// 使用 Solidity 0.8.x 内置的溢出检查，可以考虑移除 SafeMath 库
// 但如果要保留，可以继续使用
using SafeMath for uint256;

contract KEKIUS is Context, IERC20, Ownable {
    // ...（省略变量声明）...

    // 添加事件日志，记录重要操作
    event MaxTxAmountUpdated(uint256 _maxTxAmount);
    event TransferTaxUpdated(uint256 _tax);
    event FeeReduced(uint256 newFee);
    event ManualSwapExecuted(uint256 tokenAmountSwapped, uint256 ethReceived);
    event BotsAdded(address[] bots);
    event BotsRemoved(address[] notBots);
    event TradingOpened();

    modifier lockTheSwap {
        inSwap = true;
        _;
        inSwap = false;
    }
    
    constructor () {
        // 确保 _taxWallet 地址的安全性，建议设置为多签钱包地址
        _taxWallet = payable(0xa86DA6b1b09795BB2bcEe46D65b4d295Faaf002B);
        // ...（省略构造函数代码）...
    }

    // ...（省略其他函数）...

    function _transfer(address from, address to, uint256 amount) private {
        // ...（省略初始检查）...

        // 优化条件判断，减少 Gas 消耗
        if (from != owner() && to != owner()) {
            require(!bots[from] && !bots[to], "Bots are not allowed");

            uint256 contractTokenBalance = balanceOf(address(this));
            bool overMinimumTokenBalance = contractTokenBalance >= _taxSwapThreshold;

            // 在进行外部调用前，先更新状态，防止重入攻击
            if (!inSwap && from != uniswapV2Pair && swapEnabled && overMinimumTokenBalance && _buyCount > _preventSwapBefore) {
                // 根据实际情况设置交换的最大数量
                contractTokenBalance = min(amount, min(contractTokenBalance, _maxTaxSwap));
                swapTokensForEth(contractTokenBalance);
                uint256 contractETHBalance = address(this).balance;
                if (contractETHBalance > 0) {
                    sendETHToFee(contractETHBalance);
                }
            }

            uint256 taxPercentage = 0;
            if (from == uniswapV2Pair && to != address(uniswapV2Router) && !_isExcludedFromFee[to]) {
                // 买入交易
                require(amount <= _maxTxAmount, "Exceeds the _maxTxAmount");
                require(balanceOf(to).add(amount) <= _maxWalletSize, "Exceeds the _maxWalletSize");
                taxPercentage = (_buyCount >= _reduceBuyTaxAt) ? _finalBuyTax : _initialBuyTax;
                _buyCount++;
            } else if (to == uniswapV2Pair && from != address(this)) {
                // 卖出交易
                taxPercentage = (_buyCount >= _reduceSellTaxAt) ? _finalSellTax : _initialSellTax;
                // 限制每个区块的卖出次数
                if (block.number > lastSellBlock) {
                    sellCount = 0;
                    lastSellBlock = block.number;
                }
                require(sellCount < 3, "Only 3 sells per block!");
                sellCount++;
            } else {
                // 普通转账
                taxPercentage = _transferTax;
            }

            uint256 taxAmount = amount.mul(taxPercentage).div(100);

            if (taxAmount > 0) {
                _balances[address(this)] = _balances[address(this)].add(taxAmount);
                emit Transfer(from, address(this), taxAmount);
            }

            amount = amount.sub(taxAmount);
        }

        _balances[from] = _balances[from].sub(amount, "Insufficient Balance");
        _balances[to] = _balances[to].add(amount);
        emit Transfer(from, to, amount);
    }

    // 修改 swapTokensForEth 函数，添加滑点保护和状态更新
    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
        // 在外部调用前更新状态，防止重入攻击
        // inSwap 已由 lockTheSwap 修饰器处理

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();
        _approve(address(this), address(uniswapV2Router), tokenAmount);

        // 获取当前的兑换比例，设置滑点保护
        uint256[] memory amounts = uniswapV2Router.getAmountsOut(tokenAmount, path);
        uint256 amountOutMin = amounts[1].mul(95).div(100); // 允许最多 5% 的滑点

        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            amountOutMin,
            path,
            address(this),
            block.timestamp
        );
    }

    // 修改权限控制，使用 onlyOwner 修饰符
    function ReduceFee(uint256 _newFee) external onlyOwner {
        require(_newFee <= _finalBuyTax && _newFee <= _finalSellTax, "Invalid fee");
        _finalBuyTax = _newFee;
        _finalSellTax = _newFee;
        emit FeeReduced(_newFee);
    }

    function manualSwap() external onlyOwner {
        uint256 tokenBalance = balanceOf(address(this));
        if (tokenBalance > 0) {
            swapTokensForEth(tokenBalance);
        }
        uint256 ethBalance = address(this).balance;
        if (ethBalance > 0) {
            sendETHToFee(ethBalance);
        }
        emit ManualSwapExecuted(tokenBalance, ethBalance);
    }

    // ...（省略其他函数，如 addBots, delBots, openTrading 等，必要时添加事件日志）...

    // 工具函数
    function min(uint256 a, uint256 b) private pure returns (uint256) {
        return (a < b) ? a : b;
    }

    // 添加事件日志等

    // ...（省略合同末尾）...
}
```